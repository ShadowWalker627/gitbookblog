# 深拷贝和浅拷贝

## 深拷贝

拷贝所有的属性值，以及属性地址指向的值的内存空间

- 基本数据类型：变量名和值都储存在栈内存中
- 引用数据类型：变量名储存在 *栈* 内存中，值储存在 *堆* 内存中

### 1. 最简单粗暴的深拷贝方法，就是利用 JSON

```js
let newArr2 = JSON.parse(JSON.stringify(arr));
console.log(arr[0]); // {a:1, b:2}
newArr2[0].a = 123;
console.log(arr[0]); // {a:1, b:2}
```

JSON 内部用了递归的方式。数据一但过多，就会有递归爆栈的风险，还有以下问题
    - 值为 undefined 的属性在转换后丢失
    - 值为 Symbol 类型的属性在转换后丢失
    - 值为 RegExp 对象的属性在转换后变成了空对象
    - 值为 函数对象的属性在转换后丢失
    - 值为 Date 对象的属性在转换后变成了字符串
    - 会抛弃对象的 constructor,所有的构造函数会指向 Object
    - 对象的循环引用会抛出错误

### 2. _.cloneDeep

### 3. 手动实现deepClone

```js
function deepClone(obj, hash = new WeakMap()){
    //先把特殊情况全部过滤掉 null undefined date reg
    if (obj === null || obj === undefined) { return obj };  //null 和 undefined 都不用处理
    if (obj instanceof Date) { return new Date(obj); }
    if (obj instanceof RegExp) { return new RegExp(obj); }
    if (typeof obj !== 'object') { return obj; } // 普通常量直接返回

    //  防止对象中的循环引用爆栈，把拷贝过的对象直接返还即可
    if (hash.has(obj)) { return hash.get(obj); }

    // 不直接创建空对象的目的：克隆的结果和之前保持相同的所属类
    // 同时也兼容了数组的情况
    let newObj = new obj.constructor;

    hash.set(obj, newObj)  // 制作一个映射表

    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {  // 不拷贝原型链上的属性
            newObj[key] = deepClone(obj[key], hash);  // 递归赋值
        }
    }
    return newObj;
}
```

## 浅拷贝

创建一个新的对象，把原有的对象属性值，完整地拷贝过来。其中包括了基本数据类型的值和引用类型的内存地址  
只拷贝第一层的原始类型值，和第一层的引用类型地址

- Object.assign()
- Array.prototype.slice()
- Array.prototype.concat()
- ES6 的 扩展运算符
