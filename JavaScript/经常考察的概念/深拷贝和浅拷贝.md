# 深拷贝和浅拷贝

## 深拷贝

拷贝所有的属性值，以及属性地址指向的值的内存空间

- 基本数据类型：变量名和值都储存在栈内存中
- 引用数据类型：变量名储存在 *栈* 内存中，值储存在 *堆* 内存中

### 1. 最简单粗暴的深拷贝方法，就是利用 JSON

```js
let newArr2 = JSON.parse(JSON.stringify(arr));
console.log(arr[0]); // {a:1, b:2}
newArr2[0].a = 123;
console.log(arr[0]); // {a:1, b:2}
```

JSON 内部用了递归的方式。数据一但过多，就会有递归爆栈的风险，还有以下问题
    - 值为 undefined 的属性在转换后丢失
    - 值为 Symbol 类型的属性在转换后丢失
    - 值为 RegExp 对象的属性在转换后变成了空对象
    - 值为 函数对象的属性在转换后丢失
    - 值为 Date 对象的属性在转换后变成了字符串
    - 会抛弃对象的 constructor,所有的构造函数会指向 Object
    - 对象的循环引用会抛出错误

### 2. _.cloneDeep

### 3. 手动实现deepClone

```js

```

## 浅拷贝

创建一个新的对象，把原有的对象属性值，完整地拷贝过来。其中包括了原始类型的值，还有引用类型的内存地址  
只拷贝第一层的原始类型值，和第一层的引用类型地址

- Object.assign()
- Array.prototype.slice()
- Array.prototype.concat()
- ES6 的 扩展运算符
